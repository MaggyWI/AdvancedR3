---
title: "Advanced R DDEA"
author: "Ingrid M. Wagnon"
format: html
---

```{r setup}
library(tidyverse)
library(targets)
tar_config_set(store = here::here("_targets"))
source(here::here("R/functions.R"))
lipidomics <- tar_read(lipidomics)
```

## Making a table

```{r}
lipidomics |>
  group_by(metabolite) |>
  summarise(across(value, list(mean = mean, sd = sd))) |>
  mutate(across(where(is.numeric), \(x) round(x, digits = 1))) |>
  mutate(MeanSD = glue::glue("{value_mean} ({value_sd})")) |>
  select(Metabolite = metabolite, `Mean SD` = MeanSD)
```

```{r}
create_table_descriptive_stats(lipidomics)
```

## Results: Basic stats table

```{r}
tar_read(table_descriptive_stats) |>
  knitr::kable(
    caption = "The mean and standard deviation of metabolites in the lipidomics dataset."
  )
```

## Plot of distributions

```{r}
ggplot(lipidomics, aes(x = value)) +
  geom_histogram() +
  facet_wrap(vars(metabolite), scales = "free") +
  theme_minimal()
```

```{r}
create_plot_distributions(lipidomics)
```

## Results: Distribution plot

```{r}
#| fig-cap: "Plot Distribution"
tar_read(plot_distributions)
```

## Preparing the data

```{r}
lipidomics |>
  count(code, metabolite) |>
  filter(n > 1)
```

```{r}
lipidomics |>
  group_by(pick(-value)) |>
  summarise(value = mean(value), .groups = "keep") |>
  ungroup()
```

```{r}
clean(lipidomics)
```

```{r}
lipidomics
```

Now, let’s mutate our data to convert class to a factor variable and
scale value using the scale() function. The scale() function
mean-centers and scales the values so that they have a mean of 0 and
standard deviation of 1. This makes certain that each metabolite will
have the same unit and similar distribution shape.

```{r}
lipidomics |>
  filter(metabolite == "Cholesterol") |>
  mutate(
    class = as.factor(class),
    value = scale(value)
  )
```

```{r}
preprocess(lipidomics)
```

```{r}
just_cholesterol <- lipidomics |>
  filter(metabolite == "Cholesterol") |>
  preprocess()

glm(
  formula = class ~ value,
  data = just_cholesterol,
  family = binomial
) |>
  broom::tidy(exponentiate = TRUE) |>
  mutate(
    metabolite = unique(just_cholesterol$metabolite),
    model = format(class ~ value),
    .before = everything()
  )
```

```{r}
lipidomics |>
  filter(metabolite == "Cholesterol") |>
  preprocess() |>
  fit_model(class ~ value)
```

```{r}
create_model_results(lipidomics)
```

## Running multiple models

Idea : Extract list of metabolites as vector For each metabolites
preprocess and fit model (should include as many models as we need in
the function). Maybe we can use map ? So for each metabolite it will run
the function that clean/process and then run the model.

```{r}
just_cholesterol <- lipidomics |>
  filter(metabolite == "Cholesterol") |>
  preprocess()
```

```{r}
list(
  class ~ value,
  class ~ value + gender + age
)
```

data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAIAAAAUCAYAAACnOeyiAAAAXklEQVR4XmNgAIL///8zMYSGhjIDGYIMIiIMvECGMwMDN4M4kFEDUqIIZKwDMdSBjAsghj6Q8QPEMAAy/lOBoQekv4AYKkDGfgZeXl4RICOLQUtLiw3IUAJJMQIZ7AC2tU2tJWCy/wAAAABJRU5ErkJggg==
Because the fit_model() function we created earlier takes two arguments,
data and model, we need to tell map() how to use those arguments
properly. Normally, map() will give the items from the list to the first
argument of the function, which is data in our case. However, we want
the items from the list to go to the model argument instead. So, we have
to use the “anonymous function” (x) syntax to correctly put the model
items. In the anonymous function, we’ll use model as an argument, since
that is what is coming from list() and then use just_cholesterol as the
data argument in fit_model().

```{r}
list(
  class ~ value,
  class ~ value + gender + age
) |>
  map(\(model) fit_model(just_cholesterol, model = model)) |>
  list_rbind()
```

```{r}
lipidomics |>
  filter(metabolite == "Cholesterol") |>
  preprocess() |>
  fit_all_models()
```

## Running all metabolites

```{r}
lipidomics |>
  group_split(metabolite) |>
  map(preprocess) |>
  map(fit_all_models) |>
  list_rbind()
```
