---
title: "Advanced R DDEA"
author: "Ingrid M. Wagnon"
format: html
---

```{r setup}
library(tidyverse)
library(targets)
tar_config_set(store = here::here("_targets"))
source(here::here("R/functions.R"))
lipidomics <- tar_read(lipidomics)
```

## Making a table

```{r}
lipidomics |>
  group_by(metabolite) |>
  summarise(across(value, list(mean = mean, sd = sd))) |>
  mutate(across(where(is.numeric), \(x) round(x, digits = 1))) |>
  mutate(MeanSD = glue::glue("{value_mean} ({value_sd})")) |>
  select(Metabolite = metabolite, `Mean SD` = MeanSD)
```

```{r}
create_table_descriptive_stats(lipidomics)
```

## Results: Basic stats table

```{r}
tar_read(table_descriptive_stats) |>
  knitr::kable(
    caption = "The mean and standard deviation of metabolites in the lipidomics dataset."
  )
```

## Plot of distributions

```{r}
ggplot(lipidomics, aes(x = value)) +
  geom_histogram() +
  facet_wrap(vars(metabolite), scales = "free") +
  theme_minimal()
```

```{r}
create_plot_distributions(lipidomics)
```

## Results: Distribution plot

```{r}
#| fig-cap: "Plot Distribution"
tar_read(plot_distributions)
```

## Preparing the data

```{r}
lipidomics |>
  count(code, metabolite) |>
  filter(n > 1)
```

```{r}
lipidomics |>
  group_by(pick(-value)) |>
  summarise(value = mean(value), .groups = "keep") |>
  ungroup()
```

```{r}
clean(lipidomics)
```

```{r}
lipidomics
```

Now, let’s mutate our data to convert class to a factor variable and
scale value using the scale() function. The scale() function
mean-centers and scales the values so that they have a mean of 0 and
standard deviation of 1. This makes certain that each metabolite will
have the same unit and similar distribution shape.

```{r}
lipidomics |>
  filter(metabolite == "Cholesterol") |>
  mutate(
    class = as.factor(class),
    value = scale(value)
  )
```

```{r}
preprocess(lipidomics)
```

```{r}
just_cholesterol <- lipidomics |>
  filter(metabolite == "Cholesterol") |>
  preprocess()

glm(
  formula = class ~ value,
  data = just_cholesterol,
  family = binomial
) |>
  broom::tidy(exponentiate = TRUE) |>
  mutate(
    metabolite = unique(just_cholesterol$metabolite),
    model = format(class ~ value),
    .before = everything()
  )
```

```{r}
lipidomics |>
  filter(metabolite == "Cholesterol") |>
  preprocess() |>
  fit_model(class ~ value)
```

```{r}
create_model_results(lipidomics)
```

## Running multiple models

Idea : Complete the function to have both model inside : metabolite
value + metabolites value/age/sex \<- make that a vector to apply to a
function. Extract list of metabolites as vector For each metabolites
preprocess and fit model. Maybe we can use map ? So for each metabolite
it will run the function that clean/process and then run the model.

```{r}
just_cholesterol <- lipidomics |>
  filter(metabolite == "Cholesterol") |>
  preprocess()
```

```{r}
list(
  class ~ value,
  class ~ value + gender + age
)
```

Because the fit_model() function we created earlier takes two arguments,
data and model, we need to tell map() how to use those arguments
properly. Normally, map() will give the items from the list to the first
argument of the function, which is data in our case. However, we want
the items from the list to go to the model argument instead. So, we have
to use the “anonymous function” (x) syntax to correctly put the model
items. In the anonymous function, we’ll use model as an argument, since
that is what is coming from list() and then use just_cholesterol as the
data argument in fit_model().

```{r}
list(
  class ~ value,
  class ~ value + gender + age
) |>
  map(\(model) fit_model(just_cholesterol, model = model)) |>
  list_rbind()
```

```{r}
lipidomics |>
  filter(metabolite == "Cholesterol") |>
  preprocess() |>
  fit_all_models()
```

## Running all metabolites

```{r}
lipidomics |>
  group_split(metabolite) |>
  map(preprocess) |>
  map(fit_all_models) |>
  list_rbind()
```

## Figure of model estimates

```{r}
model_results <- tar_read(model_results)
```

In the graph some std.error were too big so we filter for those under 2
and some estimate were also not realistic so we filter those under 5 -
But might not be necessary in real dataset.

```{r}
model_results |>
  filter(term == "value", std.error <= 2, estimate <= 5) |>
  select(metabolite, model, estimate, std.error) |>
  ggplot(aes(
    x = estimate,
    y = metabolite,
    xmin = estimate - std.error,
    xmax = estimate + std.error
  )) +
  geom_pointrange() +
  geom_vline(xintercept = 1, linetype = "dashed") +
  facet_grid(cols = vars(model))
```

```{r}
create_plot_model_results(model_results)
```

## Model Plot

```{r}
tar_read(plot_model_results)
```

## Appendix

```{r}
tar_read(model_results) |>
  knitr::kable(caption = "Results from the analysis from all metabolites and models.")
```
